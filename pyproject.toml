[project]
name = "challange-1-book-search"
version = "0.1.0"
description = ""
authors = [
    { name = "Sóstenes Souza", email = "sostenes198br@hotmail.com" }
]
readme = "README.md"
requires-python = ">=3.12,<3.13"
dependencies = [
    "fastapi (>=0.116.2,<0.117.0)",
    "beautifulsoup4 (>=4.14.2,<5.0.0)",
    "fake-useragent (>=2.2.0,<3.0.0)",
    "httpx (>=0.28.1,<0.29.0)",
    "newrelic (>=11.0.1,<12.0.0)",
]

[tool.poetry.group.dev.dependencies]
mypy = "1.18.1"
ruff = "0.13.0"
black = "25.1.0"
pytest = "8.4.2"
poethepoet = "0.37.0"
pytest-cov = "7.0.0"
poetry-plugin-export = "1.9.0"
pip-audit = "2.9.0"
pytest-asyncio = "1.2.0"
pytest-mock = "3.15.1"
pytest-xdist = "3.8.0"
asgi-lifespan = "2.1.0"
filelock = "3.19.1"
deptry = "0.23.1"
uvicorn = { extras = ["standart"], version = "0.37.0" }
faker = "37.8.0"
respx = "0.22.0"


[build-system]
requires = ["poetry-core>=2.0.0,<3.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
package-mode = false

# ----------------------------------------------------------------------------------------------------------------------

# -----------------------------
# Black = "o Prettier do Python"
# -----------------------------
[tool.black]
line-length = 100
target-version = ["py312"]
skip-string-normalization = false
preview = false



# ----------------------------------------------
# Ruff = linter (E/F) + extras (UP/SIM/B/PL etc.)
# Também cobre isort (organização de imports)
# ----------------------------------------------
[tool.ruff]
line-length = 120
target-version = "py312"
src = ["src", "tests"]
#extend-exclude = ["infra", "docs"] # 👈 Ignora essas pastas

[tool.ruff.lint]
select = [
    "E", # pycodestyle (estilo)
    "F", # pyflakes (erros)
    #  "I",   # isort (imports)
    "UP", # pyupgrade (idiomático p/ versões recentes)
    "B", # flake8-bugbear (armadilhas comuns)
    "SIM", # flake8-simplify (simplificações)
    "PL", # pylint (subset útil)
]
ignore = [
    "E203", # compat Black (slice spacing)
    "E266", # muitos '#'
    #  "E501",  # comprimento de linha (Black cuida disso),
    "PLR2004",
    "B010",
    "B039",
    "PLW0603",
    "PLR0913"
]
# Você pode “afrouxar” regras aqui se ficar muito rígido.

[tool.ruff.lint.per-file-ignores]
"tests/**/*.py" = [
    "PLR2004",
    "PLR0915",
    "PLR0913",
    "PLR0912",
    "PLR0911",
    "E501",
    "B017"
]

[tool.ruff.lint.isort]
combine-as-imports = true
force-single-line = false
known-first-party = ["challange-1-book-search"]   # ajuste para seu(s) pacote(s)
section-order = ["future", "standard-library", "third-party", "first-party", "local-folder"]



# -----------------------------------------
# mypy = checagem de tipos (Type Hints PEP)
# -----------------------------------------
[tool.mypy]
python_version = "3.12"
files = ["src", "tests"]
#exclude = '(^|/)(infra|docs)(/|$)'  # 👈 Ignora essas pastas
warn_return_any = true
warn_unused_ignores = true
warn_redundant_casts = true
no_implicit_optional = true
check_untyped_defs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
strict_optional = true
pretty = true
#ignore_missing_imports = true   # útil p/ libs sem stubs; pode remover se quiser rigor máximo

# Opcional: excluir diretórios gerados
#mypy_path = ["src", "tests"]




# -----------------------------------------
# deptry
# -----------------------------------------

#[tool.deptry]
#ignore = ["DEP002", "DEP003"] # Você pode desligar a regra toda

[tool.deptry.per_rule_ignores]
DEP002 = ["uvicorn", "newrelic"]   # ignorar "unused dependency"
DEP003 = ["pydantic"]  # ignorar "transitive dependency"



# -----------------------------------------
# pytest
# -----------------------------------------
[tool.pytest.ini_options]
# Descobrir testes só em tests/
testpaths = ["tests"]
# Evitar descer em infra/ e docs/
#norecursedirs = ["infra", "docs"]
# Garante que o src/ entre no sys.path
asyncio_mode = "auto"   # faz o pytest detectar testes async automaticamente
#asyncio_default_fixture_loop_scope = "session"
pythonpath = ["src"]
markers = [
    "unit: fast unit tests",
    "integration: integration tests (may touch external services)",
    "e2e: end-to-end tests (slow, full stack)",
]
addopts = [
    "-ra",
    "--strict-markers",
]
#log_cli = true
#log_cli_level = "INFO"

[tool.coverage.run]
data_file = "coverage/.coverage"
branch = true
source = ["src"]

# Se usa threads/processos ou pytest-xdist / subprocessos
#parallel = true
#concurrency = ["thread", "multiprocessing"]

# (Opcional) contexto por teste — ótimo para diagnóstico fino
#dynamic_context = "test_function"

# Inclua/omita conforme seu repo
# include = ["src/**/*.py"]
omit = [
    "src/AppBuilder.py",
    "src/**/Main.py",
    "tests/*",
    "infra/*",
    "docs/*",
    "*/migrations/*",
    "*/.venv/*",
    "*/venv/*",
    "*/__init__.py",
    "*/__main__.py", # se não quer medir entrypoints CLIs

]

[tool.coverage.report]
show_missing = true
precision = 2 # casas decimais no percentual (só estética, mas ajuda).
#skip_covered = true # esconde arquivos 100% cobertos (relatório menor).
#fail_under = 80  # opcional: quebra build se <80%

# Linhas que o coverage deve ignorar (padrões comuns)
exclude_lines = [
    "pragma: no cover",
    "if TYPE_CHECKING:",
    "if __name__ == .__main__.:",
    "pass",
    # "@abstractmethod",
    # "Abstract"
    #  "raise NotImplementedError",
]

[tool.coverage.html]
directory = "coverage/cov_html"

[tool.coverage.xml]
output = "coverage/coverage_xml"

# (Opcional) se quiser JSON:
# [tool.coverage.json]
# output = "coverage/coverage_json"



# -----------------------------------------
# Tasks com Poe the Poet
# -----------------------------------------
[tool.poe.tasks]
export_requirements_prod = { cmd = "poetry export -f requirements.txt --without-hashes -o requirements.txt" }
export_requirements_all = { cmd = "poetry export -f requirements.txt --without-hashes --with dev -o requirements-all.txt" }
export_requirements_dev = { cmd = "poetry export -f requirements.txt --without-hashes --only dev -o requirements-dev.txt" }
export_all_requirements = { sequence = [
    "export_requirements_prod",
    "export_requirements_all",
    "export_requirements_dev",
] }
clean_coverage = { cmd = "python -c \"import shutil, pathlib; p=pathlib.Path('coverage'); shutil.rmtree(p, ignore_errors=True)\"" }
clean_all = { sequence = [
    "clean_coverage"
] }
check_deep_dependencies = { cmd = "deptry ." }
audit = { sequence = [
    { cmd = "python -c \"import pathlib; pathlib.Path('requirements-all.txt').unlink(missing_ok=True)\"" },
    { cmd = "poetry check" },
    "export_requirements_all",
    { cmd = "pip-audit -r requirements-all.txt --strict" },
    "check_deep_dependencies"
] }
fmt = { cmd = "black src tests" }
lint = { sequence = [ # --verbose with need more details
    { cmd = "ruff check . --fix --select F401,UP006,E501,UP035,SIM118,UP045,UP046" },
    { cmd = "ruff check" }
] }
typecheck = { cmd = "mypy" }
test_unit = { sequence = [
    "clean_coverage",
    { cmd = "pytest -m unit --cov-context=test --cov=src --cov-report=xml --cov-report=html --cov-report=term-missing -n auto --dist loadfile -v" }] }
test_integration = { cmd = "pytest -m integration -n auto -s --dist loadfile -v" }
test_e2e = { cmd = "pytest -m e2e -n auto --dist loadfile -v" }
pre_commit = { sequence = ["fmt", "lint", "typecheck", "audit"] }